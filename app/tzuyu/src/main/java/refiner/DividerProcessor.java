package refiner;

import java.util.ArrayList;
import java.util.List;


import refiner.bool.BooleanIsFalseAtom;
import refiner.bool.CharEqualsValueAtom;
import refiner.bool.EnumEqualsConstant;
import refiner.bool.FieldVar;
import refiner.bool.LIAAtom;
import refiner.bool.LIATerm;
import refiner.bool.ObjectIsNullAtom;
import refiner.bool.Operator;
import refiner.bool.StringEqualsValueAtom;

import tzuyu.engine.bool.Atom;
import tzuyu.engine.bool.DNF;
import tzuyu.engine.bool.DNFTerm;
import tzuyu.engine.bool.Literal;
import tzuyu.engine.model.Formula;
import tzuyu.engine.utils.Pair;
import tzuyu.engine.utils.Permutation;
import tzuyu.engine.utils.TzuYuPrimtiveTypes;


/**
 * Process the raw divider generated by SVM by mapping categorical fields back
 * into user readable format.
 * 
 * @author Spencer Xiao
 * 
 */
public class DividerProcessor {

  /**
   * <p>
   * Process a set of terms returned by LibSVM to generate a human readable
   * proposition. Each term returned by LibSVM is of the form
   * <code>coeff*var</code> and the terms are the LHS of the divider and bias
   * the RHS of the divider.
   * 
   * <p>
   * This method first try to identify the set of categorical variables and
   * generate all possible assignments for these variables. For each assignment,
   * it calculates the sum of <code>coeff*value</code> of the categorical
   * variables under this assignment to get the <i>offset</i> and then
   * calculates the <i>remaining bias</i> for the numerical variables by
   * subtracting the <i>offset</i> from the parameter {@link bias}. The
   * remaining numerical variables and the remaining bias form an atom in the
   * LRA theory. Then by making conjunction of the atoms of each categorical
   * variables with the LRA atom we get a term in the DNF for each assignment.
   * Then it forms the final human readable formula by making disjunction of all
   * the DNF terms for each assignment.
   * 
   * @param terms
   *          the left hand side of the divider returned by LibSVM
   * @param bias
   *          the right hand side of the divider returned by LibSVM
   * @return the equivalent and human readable form of the raw divider.
   */
  public static Formula process(List<LIATerm> terms, double bias) {
    if (terms == null || terms.size() == 0) {
      throw new IllegalArgumentException("the size of terms must be positive");
    }

    // Step 1: Classify the terms into categorical and numerical,
    // Please note that Java reference types are treated as categorical
    // types with two values.
    List<TypeTerm> categoricals = new ArrayList<TypeTerm>();
    List<TypeTerm> numericals = new ArrayList<TypeTerm>();
    for (LIATerm term : terms) {
      Class<?> type = term.getVariable().getType();
      if (TzuYuPrimtiveTypes.isCategorical(type)) {
        categoricals.add(new TypeTerm(type, term));
      } else if (TzuYuPrimtiveTypes.isNumerical(type)) {
        numericals.add(new TypeTerm(type, term));
      } else {
        // Reference types are treated as a categorical variable with two
        // values(i.e., referenceObject==null and referencesObject!=null).
        categoricals.add(new TypeTerm(type, term));
      }
    }

    if (categoricals.size() == 0 && numericals.size() == 0) {
      // Case 0: There is no variables referenced in the divider,
      // This should not happen in practice, If so, we just return "True"
      return Formula.TRUE;
    } else if (numericals.size() == 0) {
      // Case 1: The divider contains only categorical or reference variables.
      List<Integer> domains = new ArrayList<Integer>();

      for (int index = 0; index < categoricals.size(); index++) {
        TypeTerm term = categoricals.get(index);
        int size = TzuYuPrimtiveTypes.getDomainSize(term.first());
        domains.add(size);
      }

      DNF divider = new DNF();
      // Step 2:Generate one assignment for categorical types
      Permutation permutation = new Permutation(domains, true);
      while (permutation.hasNext()) {
        List<Integer> indices = permutation.next();
        // Step 3: Calculate the offset of categorical values under
        // this assignment
        double offset = 0.0;
        for (int index = 0; index < indices.size(); index++) {
          TypeTerm term = categoricals.get(index);
          double coeff = term.second().getCoefficient();
          offset += coeff
              * TzuYuPrimtiveTypes.getNumeicalValue(term.first(),
                  indices.get(index));
        }

        if (offset >= bias) {
          // The raw divider is valid under current assignment

          // Construct the term of valid assignment of the final DNF.
          DNFTerm term = constructCategoricalConstraint(categoricals, indices);
          divider.addTerm(term);
        }
      }
      return divider;

    } else if (categoricals.size() == 0) {
      // Case 2: The divider contains only numerical variables
      return constructNumericalContraint(numericals, Operator.GE, bias);
    } else {
      // Case 3: The divider contains both numerical and
      // categorical types variables

      // Get the domain size for categorical features
      List<Integer> domains = new ArrayList<Integer>();
      for (int index = 0; index < categoricals.size(); index++) {
        TypeTerm term = categoricals.get(index);
        int size = TzuYuPrimtiveTypes.getDomainSize(term.first());
        domains.add(size);
      }

      DNF divider = new DNF();

      Permutation permutation = new Permutation(domains, true);
      while (permutation.hasNext()) {
        // Generate one assignment
        List<Integer> indices = permutation.next();
        // Calculate the offset of categorical values for this assignment
        double offset = 0.0;
        for (int index = 0; index < indices.size(); index++) {
          TypeTerm term = categoricals.get(index);
          double coeff = term.second().getCoefficient();
          offset += coeff* TzuYuPrimtiveTypes.getNumeicalValue(term.first(),
                  indices.get(index));
        }

        // construct the categorical part of the term of current assignment
        DNFTerm dnfTerm = constructCategoricalConstraint(categoricals, indices);
        // Construct the numerical part of the term of current assignment
        Literal numericalLiteral = constructNumericalContraint(numericals,
            Operator.GE, bias - offset);
        // Add both categorical and numerical part to form the term of
        // current assignment.
        dnfTerm.addLiteral(numericalLiteral);

        divider.addTerm(dnfTerm);
      }

      return divider;
    }
  }

  /**
   * Form an LRA atom with the numerical variables and the new bias.
   *
   * @param numericals
   * @param op
   * @param bias
   * @return
   */
  private static Literal constructNumericalContraint(
      List<TypeTerm> numericals, Operator op, double bias) {

    // post-process the numerical coefficients 
    if (numericals.size() == 1) {
      LIATerm term = numericals.get(0).second();
      double coeff = term.getCoefficient();
      FieldVar var = term.getVariable();
      if (var.getType().equals(int.class)) {
        double b = bias/coeff;
        long intPart = (long) b;
        List<LIATerm> liaTerms = new ArrayList<LIATerm>(1);
        liaTerms.add(new LIATerm(var, 1));
     
        long newBias  = intPart;
        if (coeff > 0) {
          newBias = ( intPart == b || b < 0) ? intPart : (intPart + 1);
          LIAAtom newAtom = new LIAAtom(liaTerms, op, newBias);
          return new Literal(newAtom, false);
        } else {
          newBias = (intPart == b || b > 0) ? intPart : (intPart - 1);
          LIAAtom newAtom = new LIAAtom(liaTerms, Operator.LE, newBias);
          return new Literal(newAtom, false);
        } 
      } else {
        if (Math.abs(coeff) < 1) {
          List<LIATerm> liaTerms = new ArrayList<LIATerm>(1);
          if (Math.abs(coeff) > Math.abs(bias)) {     
            liaTerms.add(new LIATerm(var, Math.round(coeff/bias)));
            LIAAtom newAtom = new LIAAtom(liaTerms, op, 1);
            return new Literal(newAtom, bias < 0);
          } else {
            liaTerms.add(new LIATerm(term.getVariable(), 1));
            LIAAtom newAtom = new LIAAtom(liaTerms, op, Math.round(bias/coeff));
            return new Literal(newAtom, coeff < 0);
          }
        } 
      }
    }
    
    List<LIATerm> liaTerms = new ArrayList<LIATerm>(numericals.size());
    for (int index = 0; index < numericals.size(); index++) {
      TypeTerm typedTerm = numericals.get(index);
      LIATerm term = typedTerm.second();
      LIATerm newTerm = new LIATerm(term.getVariable(), 
          term.getCoefficient());
      liaTerms.add(newTerm);
    }
    
    Atom liaAtom = new LIAAtom(liaTerms, op, bias);

    return new Literal(liaAtom, false);
  }

  /**
   * Get the conjunction of the categorical variables under this assignment.
   * each atom in this DNF term has the form of <code>var == value</code>.
   * 
   * @param categorical
   * @param indices
   * @return
   */
  private static DNFTerm constructCategoricalConstraint(
      List<TypeTerm> categorical, List<Integer> indices) {

    if (categorical.size() != indices.size()) {
      throw new IllegalArgumentException("variable and "
          + "valuation do not have same size");
    }

    DNFTerm constraint = new DNFTerm();
    for (int index = 0; index < indices.size(); index++) {
      TypeTerm term = categorical.get(index);
      Class<?> type = term.first();
      int valueIndex = indices.get(index);
      if (type.equals(boolean.class) || type.equals(Boolean.class)) {
        Atom atom = new BooleanIsFalseAtom(term.second().getVariable());
        boolean isTrue = TzuYuPrimtiveTypes.isBooleanTrue(type, valueIndex);
        constraint.addLiteral(new Literal(atom, isTrue));
      } else if (type.equals(String.class)) {
        Atom atom = new StringEqualsValueAtom(term.second().getVariable(),
            TzuYuPrimtiveTypes.getString(type, valueIndex));
        constraint.addLiteral(new Literal(atom, false));
      } else if (type.equals(char.class) || type.equals(Character.class)) {
        Atom atom = new CharEqualsValueAtom(term.second().getVariable(),
            TzuYuPrimtiveTypes.getChar(type, valueIndex));
        constraint.addLiteral(new Literal(atom, false));
      } else if (type.isEnum()) {
        Atom atom = new EnumEqualsConstant(term.second().getVariable(),
            TzuYuPrimtiveTypes.getEnum(type, valueIndex));
        constraint.addLiteral(new Literal(atom, false));
      } else {// The reference type variable
        Atom atom = new ObjectIsNullAtom(term.second().getVariable());
        boolean isNull = TzuYuPrimtiveTypes.isNullReference(type, valueIndex);
        constraint.addLiteral(new Literal(atom, !isNull));
      }
    }
    return constraint;
  }
}

/**
 * The internal helper class is a pair of the type of variable referenced in the
 * LIATerm and the LIATerm itself.
 * 
 * @author Spencer Xiao
 * 
 */
class TypeTerm extends Pair<Class<?>, LIATerm> {

  public TypeTerm(Class<?> a, LIATerm b) {
    super(a, b);
  }

}
